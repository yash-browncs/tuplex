General tuplex notes

- Logical (reordering operators (map vs filter)) / Physical (realizing implementation of logical)
- Pipeline breakers (can't pipe anymore, need to materialize)
- Staging is related to pipeline breakers (need to join first before continuing, constitutes a stage)
- Flask pipelines
- for filter specifically, look at resolve task

Debugging tricks

- set everything single threaded (executorCount = 0)!!
- set breakpoints anywhere you want, then inspect. 
  (check if code is triggered correctly. check if exception is decoded in the resolve task.
    then after resolve is it merged back correctly? somewhere in between stuff might break)
- in python fallback, ben discovered bugs. Can get python code out then use in Jupyter.
- copy value of pycode field from stage builder. 
- transformstage01.py file contains python code in debug mode
- look at output files in ./build
- copy function in python file ("b'\x80\x05\x95\x8a\x01\x00\x00\x00\x00\x00\x00\x8c\x17\x63\x6c\x6f\x75\x64\x70\x69\x63\x6b\x6c\x65\x2e\x63\x6c\x6f\x75\x64\x70\x69\x63\x6b\x6c\x65\x94\x8c\x0d\x5f\x62\x75\x69\x6c\x74\x69\x6e\x5f\x74\x79\x70\x65\x94\x93\x94\x8c\x0a\x4c\x61\x6d\x62\x64\x61\x54\x79\x70\x65\x94\x85\x94\x52\x94\x28\x68\x02\x8c\x08\x43\x6f\x64\x65\x54\x79\x70\x65\x94\x85\x94\x52\x94\x28\x4b\x01\x4b\x00\x4b\x00\x4b\x01\x4b\x02\x4b\x43\x43\x08\x7c\x00\x64\x01\x6b\x08\x53\x00\x94\x4e\x4b\x02\x86\x94\x29\x8c\x01\x78\x94\x85\x94\x8c\x09\x63\x6f\x6e\x73\x6f\x6c\x65\x2d\x31\x94\x8c\x08\x3c\x6c\x61\x6d\x62\x64\x61\x3e\x94\x4b\x01\x43\x00\x94\x29\x29\x74\x94\x52\x94\x7d\x94\x4e\x4e\x4e\x74\x94\x52\x94\x8c\x1c\x63\x6c\x6f\x75\x64\x70\x69\x63\x6b\x6c\x65\x2e\x63\x6c\x6f\x75\x64\x70\x69\x63\x6b\x6c\x65\x5f\x66\x61\x73\x74\x94\x8c\x12\x5f\x66\x75\x6e\x63\x74\x69\x6f\x6e\x5f\x73\x65\x74\x73\x74\x61\x74\x65\x94\x93\x94\x68\x14\x7d\x94\x7d\x94\x28\x8c\x08\x5f\x5f\x6e\x61\x6d\x65\x5f\x5f\x94\x68\x0e\x8c\x0c\x5f\x5f\x71\x75\x61\x6c\x6e\x61\x6d\x65\x5f\x5f\x94\x68\x0e\x8c\x0f\x5f\x5f\x61\x6e\x6e\x6f\x74\x61\x74\x69\x6f\x6e\x73\x5f\x5f\x94\x7d\x94\x8c\x0e\x5f\x5f\x6b\x77\x64\x65\x66\x61\x75\x6c\x74\x73\x5f\x5f\x94\x4e\x8c\x0c\x5f\x5f\x64\x65\x66\x61\x75\x6c\x74\x73\x5f\x5f\x94\x4e\x8c\x0a\x5f\x5f\x6d\x6f\x64\x75\x6c\x65\x5f\x5f\x94\x4e\x8c\x07\x5f\x5f\x64\x6f\x63\x5f\x5f\x94\x4e\x8c\x0b\x5f\x5f\x63\x6c\x6f\x73\x75\x72\x65\x5f\x5f\x94\x4e\x8c\x17\x5f\x63\x6c\x6f\x75\x64\x70\x69\x63\x6b\x6c\x65\x5f\x73\x75\x62\x6d\x6f\x64\x75\x6c\x65\x73\x94\x5d\x94\x8c\x0b\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f\x94\x7d\x94\x75\x86\x94\x86\x52\x30\x2e'") to jupyter notebook

----------------

Leonhard
-- have way more elements per list.
-- list contained should be smaller, random size.
-- sketch the graph from whiteboard on google slides.
-- fix unordered_map 

-- add standard deviation.

(python baseline vs c++ is x% slower.)

-- assume key distribution.
    - have statistics of key distribution and can do something smart about it.

-- multiple queries is our edge
-- real data more compelling than artificial data

Unknowns
- for replace, what should keys look like?
- what does reorganize data mean exactly

Immediate TODOs:
- write string parser to identify type.
- write specialized c++ code for int only (use boolean array, specialized hash function, etc.)

Workloads
- count unique (update dictionary per iteration, inserts decrease over time, only numkeys lookup)
- replace (lookup dictionary per iteration, once everything inserted, only lookups)
- reorganize data (JSON -> list?) (need only traverse tree structure once)

Code todo
- write python version of replace
- write cython version of unique, replace
- write cpp version of optimized float/int/string/bool only map/unordered_map 

Plots todo
- create multiple maps vs one map std variant/wrapper type
  (one per type, fixing key per map, --> plot runtime vs length per list (3x unordered map, 3x ordered_map)
   val always fixed to int)